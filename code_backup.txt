# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main_app.ui'
#
# Created by: PyQt5 UI code generator 5.9
#
# WARNING! All changes made in this file will be lost!

## Add mean, std. dev. of carton demand
## Add time to sort, etc. as inputs (upper bound, lower bound, mean) -> Generate distribution based on inputs (either uniform or triangular)


## Add number of iterations (simulated days) as an input

## Add min, max, & mean number time to sort each carton figures (seconds)
## 2 GUIs in one app - 1 for daily demand & 1 for seasonal demand

import pandas as pd
import numpy as np
import math
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QIntValidator, QDoubleValidator

class Ui_MainWindow(object):

    def setupUi(self, MainWindow):
        ## INITIAL SETUP ##
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1200, 800)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        ## PUSH BUTTON SETUP ##
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(340, 450, 91, 51))
        self.pushButton.setObjectName("pushButton")

        ## INPUT BOXES SETUP ##
        self.meanDemandInput = QtWidgets.QLineEdit(self.centralwidget)
        self.meanDemandInput.setGeometry(QtCore.QRect(50, 120, 130, 50))
        self.meanDemandInput.setText("")
        self.meanDemandInput.setObjectName("meanDemandInput")
        self.associatesInput = QtWidgets.QLineEdit(self.centralwidget)
        self.associatesInput.setGeometry(QtCore.QRect(190, 120, 130, 50))
        self.associatesInput.setText("")
        self.associatesInput.setObjectName("associatesInput")
        self.stdDemandInput = QtWidgets.QLineEdit(self.centralwidget)
        self.stdDemandInput.setGeometry(QtCore.QRect(330, 120, 130, 50))
        self.stdDemandInput.setText("")
        self.stdDemandInput.setObjectName("stdDemandInput")
        self.minTimeInput = QtWidgets.QLineEdit(self.centralwidget)
        self.minTimeInput.setGeometry(QtCore.QRect(470, 120, 130, 50))
        self.minTimeInput.setText("")
        self.minTimeInput.setObjectName("minTimeInput")
        self.maxTimeInput = QtWidgets.QLineEdit(self.centralwidget)
        self.maxTimeInput.setGeometry(QtCore.QRect(610, 120, 130, 50))
        self.maxTimeInput.setText("")
        self.maxTimeInput.setObjectName("maxTimeInput")
        self.meanTimeInput = QtWidgets.QLineEdit(self.centralwidget)
        self.meanTimeInput.setGeometry(QtCore.QRect(750, 120, 130, 50))
        self.meanTimeInput.setText("")
        self.meanTimeInput.setObjectName("meanTimeInput")
        self.iterationsInput = QtWidgets.QLineEdit(self.centralwidget)
        self.iterationsInput.setGeometry(QtCore.QRect(890, 120, 130, 50))
        self.iterationsInput.setText("")
        self.iterationsInput.setObjectName("iterationsInput")
        self.inputs = [self.meanDemandInput, self.associatesInput, self.stdDemandInput,
                       self.minTimeInput, self.maxTimeInput, self.meanTimeInput,
                       self.iterationsInput]


        ## OUTPUT BOXES SETUP ##
        self.currentHours = QtWidgets.QTextBrowser(self.centralwidget)
        self.currentHours.setGeometry(QtCore.QRect(120, 250, 141, 111))
        self.currentHours.setObjectName("currentHours")
        self.optimalHours = QtWidgets.QTextBrowser(self.centralwidget)
        self.optimalHours.setGeometry(QtCore.QRect(330, 250, 141, 111))
        self.optimalHours.setObjectName("optimalHours")
        self.optimalAss = QtWidgets.QTextBrowser(self.centralwidget)
        self.optimalAss.setGeometry(QtCore.QRect(530, 250, 141, 111))
        self.optimalAss.setObjectName("optimalAss")
        self.outputs = [self.currentHours, self.optimalHours, self.optimalAss]

        ## LABELS SETUP ##
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(70, 80, 71, 31))
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(210, 80, 101, 21))
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(130, 210, 131, 31))
        self.label_3.setObjectName("label_3")
        self.label_4 = QtWidgets.QLabel(self.centralwidget)
        self.label_4.setGeometry(QtCore.QRect(340, 210, 131, 31))
        self.label_4.setObjectName("label_4")
        self.label_5 = QtWidgets.QLabel(self.centralwidget)
        self.label_5.setGeometry(QtCore.QRect(540, 210, 131, 31))
        self.label_5.setObjectName("label_5")
        self.label_6 = QtWidgets.QLabel(self.centralwidget)
        self.label_6.setGeometry(QtCore.QRect(330, 80, 140, 31))
        self.label_6.setObjectName("label_6")
        self.label_7 = QtWidgets.QLabel(self.centralwidget)
        self.label_7.setGeometry(QtCore.QRect(480, 80, 131, 31))
        self.label_7.setObjectName("label_7")
        self.label_8 = QtWidgets.QLabel(self.centralwidget)
        self.label_8.setGeometry(QtCore.QRect(620, 80, 131, 31))
        self.label_8.setObjectName("label_8")
        self.label_9 = QtWidgets.QLabel(self.centralwidget)
        self.label_9.setGeometry(QtCore.QRect(760, 80, 131, 31))
        self.label_9.setObjectName("label_9")
        self.label_10 = QtWidgets.QLabel(self.centralwidget)
        self.label_10.setGeometry(QtCore.QRect(900, 80, 131, 31))
        self.label_10.setObjectName("label_10")

        ## MENU & TOOL BAR SETUP ##
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.toolBar = QtWidgets.QToolBar(MainWindow)
        self.toolBar.setObjectName("toolBar")
        MainWindow.addToolBar(QtCore.Qt.TopToolBarArea, self.toolBar)

        ## PUSH BUTTON ACTIONS ##
        self.pushButton.clicked.connect(self.buttonClicked)

        ## VALIDATORS
        self.onlyInt = QIntValidator()
        self.meanDemandInput.setValidator(self.onlyInt)
        self.associatesInput.setValidator(self.onlyInt)
        self.onlyDouble = QDoubleValidator()
        self.meanTimeInput.setValidator(self.onlyDouble)

        ## RETRANSLATING ##
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def buttonClicked(self):
        for output in self.outputs: ## Clears all output boxes
            output.clear()
        ########################################### CONSTANT ###########################################
        self.currentHours.insertPlainText(str(self.computeConstant(int(self.meanDemandInput.text()),
                                          int(self.associatesInput.text()),
                                           float(self.meanTimeInput.text()), 1.4)[1])) # Change to round
        ################################################################################################
        ########################################### UNIFORM ############################################
        self.currentHours.insertPlainText(str(self.computeUniform(int(self.meanDemandInput.text()),
                                                                   int(self.associatesInput.text()),
                                                                   float(self.meanTimeInput.text()), 1.4)[1])) # Change to round
        ################################################################################################


    #########   START SCRIPTING FUNCTIONS    #########

    # Computes the optimal number of associates w/ respective day-hours
    @staticmethod
    def computeConstant(dailyDemand, numAssociates, constantSort, bufferNum):    ## CHANGE THIS
        sort_list = []
        for carton in range(dailyDemand):
            sort_list.append(constantSort)
        data = pd.read_csv('WSI_dimensional_data.csv')
        volume = data['Volume']
        # dimensional data
        pallets = 0
        vol = 0
        dims = np.random.choice(volume, dailyDemand)
        for i in range(len(dims)):
            if vol + dims[i] > 115000:
                pallets += 1
                vol = dims[i]
            else:
                vol += dims[i]
            if dims[i] > 23000:
                sort_list[i] = sort_list[i] * 2
        loading_time = np.random.uniform(1200, 1800)
        if pallets > 12:
            loading_time = loading_time * 2
        # sum of all sorting times + sum of all loading times
        # + constant value for wrapping times the buffer which accounts for staging
        manHours = ((sum(sort_list) + loading_time + pallets * 90) * bufferNum) / 3600
        no_hours_current = manHours / numAssociates
        if manHours < 18:
            optimal_associates = 2
            no_hours_optimal = manHours / 2
        else:
            optimal_associates = math.ceil(manHours / 9)
            no_hours_optimal = manHours / optimal_associates
        outputList = [optimal_associates, no_hours_current, no_hours_optimal]
        return outputList

    @staticmethod
    def computeUniform(dailyDemand, numAssociates, minSort, maxSort, bufferNum):
        sort_list = []
        for carton in range(dailyDemand):
            sort_list.append(np.random.uniform(minSort, maxSort))
        data = pd.read_csv('WSI_dimensional_data.csv')
        volume = data['Volume']
        pallets = 0
        vol = 0
        dims = np.random.choice(volume, dailyDemand)
        for i in range(len(dims)):
            if vol + dims[i] > 115000:
                pallets += 1
                vol = dims[i]
            else:
                vol += dims[i]
            if dims[i] > 23000:
                sort_list[i] = sort_list[i] * 2
        loading_time = np.random.uniform(1200, 1800)
        if pallets > 12:
            loading_time = loading_time * 2
        # sum of all sorting times + sum of all loading times
        # + constant value for wrapping times the buffer which accounts for staging
        manHours = ((sum(sort_list) + loading_time + pallets * 90) * bufferNum) / 3600
        no_hours_current = manHours / numAssociates
        if manHours < 18:
            optimal_associates = 2
            no_hours_optimal = manHours / 2
        else:
            optimal_associates = math.ceil(manHours / 9)
            no_hours_optimal = manHours / optimal_associates
        outputList = [optimal_associates, no_hours_current, no_hours_optimal]
        return outputList
    #########   END SCRIPTING FUNCTIONS    #########




    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "Calculate"))
        self.label.setText(_translate("MainWindow", "Demand"))
        self.label_2.setText(_translate("MainWindow", "Current Associates"))
        self.label_3.setText(_translate("MainWindow", "Number Hours w/ Current"))
        self.label_4.setText(_translate("MainWindow", "Number Hours w/ Optimal"))
        self.label_5.setText(_translate("MainWindow", "Optimal Number Associates"))
        self.label_6.setText(_translate("MainWindow", "Standard Deviation Demand"))
        self.label_7.setText(_translate("MainWindow", "Min Time to Sort"))
        self.label_8.setText(_translate("MainWindow", "Max Time to Sort"))
        self.label_9.setText(_translate("MainWindow", "Mean Time to Sort"))
        self.label_10.setText(_translate("MainWindow", "Number Simulated Days"))
        self.toolBar.setWindowTitle(_translate("MainWindow", "toolBar"))

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
